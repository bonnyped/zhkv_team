# Проект “Симуляция”

## Описание

Пошаговая симуляция 2D мира, населённого травоядными и хищниками. Кроме существ, мир содержит ресурсы (траву), которыми питаются травоядные, и статичные объекты, с которыми нельзя взаимодействовать — они просто занимают место.

2D мир — матрица NxM. Каждое существо или объект занимает клетку целиком, нахождение в клетке нескольких объектов/существ недопустимо.

> Идея взята отсюда и упрощена.  
> [Комментарии по проекту](https://www.youtube.com/watch?v=3Vrwx4iryhw)

---

## Что нужно знать

- Java: коллекции, ООП

---

## Мотивация проекта

Основная цель — демонстрация принципов дизайна архитектуры приложения с помощью ООП. Описанная ниже структура классов не является всеобъемлющей, предполагается, что студент будет ей следовать, взяв за основу.

---

## Дизайн классов

### Entity

Корневой абстрактный класс для всех существ и объектов, существующих в симуляции.

### Grass, Rock, Tree

- **Rock, Tree** — статичные объекты.
- **Grass** — ресурс для травоядных.

### Creature

Абстрактный класс, наследуется от Entity.  
Существо, имеет скорость (сколько клеток может пройти за 1 ход), количество HP.  
Имеет метод `makeMove()` — сделать ход.

### Herbivore

Травоядное, наследуется от Creature.  
Стремится найти ресурс (траву), может потратить свой ход на движение в сторону травы либо на её поглощение.

### Predator

Хищник, наследуется от Creature.  
В дополнение к полям класса Creature, имеет силу атаки.

На что может потратить ход хищник:
- Переместиться (чтобы приблизиться к жертве — травоядному)
- Атаковать травоядное. При этом количество HP травоядного уменьшается на силу атаки хищника. Если значение HP жертвы опускается до 0, травоядное исчезает.

### Map

Карта, содержит коллекцию для хранения существ и их расположения.  
Совет: не спешите использовать двумерный массив или список списков, подумайте, какие ещё коллекции могут подойти.

### Simulation

Главный класс приложения, включает:
- Карту
- Счётчик ходов
- Рендерер поля
- Actions — список действий, исполняемых перед стартом симуляции или на каждом ходу

#### Методы:
- `nextTurn()` — просимулировать и отрендерить один ход
- `startSimulation()` — запустить бесконечный цикл симуляции и рендеринга
- `pauseSimulation()` — приостановить бесконечный цикл симуляции и рендеринга

---

## Actions

**Action** — действие, совершаемое над миром.  
Например: сходить всеми существами (итерировать существ и вызвать каждому `makeMove()`).

Каждое действие описывается отдельным классом и совершает операции над картой.

Симуляция содержит 2 массива действий:
- **initActions** — действия перед стартом симуляции (например, расставить объекты и существ на карте)
- **turnActions** — действия каждый ход (например, передвижение существ, добавление травы или травоядных, если их осталось слишком мало)

---

## Поиск пути

Рекомендуется писать алгоритм поиска пути с нуля, используя описание алгоритма на Википедии.  
Проще всего начать с алгоритма поиска в ширину (BFS). Он относительно простой, но может работать медленно на больших полях — для них лучше подойдёт алгоритм A*.

---

## Рендерер

Рендерер отвечает за визуализацию состояния поля, его отрисовку.  
Интерфейс приложения может быть консольным либо графическим — на выбор студента.

---

## Конечная цель

Реализовать симуляцию и подобрать различные значения так, чтобы взаимодействия внутри мира получились максимально интересными:

- Размер поля
- Диапазоны HP и скорости существ
- Диапазон атаки хищников

### Опциональные идеи для усложнения проекта

- Механика размножения существ
- Механика голода (отсутствие пищи уменьшает HP)

---

## Ресурсы для работы над ошибками

- Эталонная реализация проекта похожего уровня сложности, написанного на серии стримов
- Реализации проекта другими студентами и мои ревью этих реализаций
- Чеклист для самопроверки с типовыми ошибками (в конце страницы)

Присылайте законченные проекты в чат — добавляю их в список, сообщество делает ревью проектов.